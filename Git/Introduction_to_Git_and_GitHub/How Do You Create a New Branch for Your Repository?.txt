You've previously learned how to commit changes and push them up to your remote repository, but all of that has been on your default main branch. That can work for a smaller project, but as you contribute to other open source projects, or as your project grows, branches are essential.

For example, if you fork a repository and make commits to the main branch of your fork, you may end up with changes in your fork that the original repository did not accept. This can make it incredibly difficult to update your branch with the changes from the fork that were accepted. Or, when working on your own project, switching between different tasks becomes much more difficult if you are not using branches. Instead, you have to manually keep track of which changes relate to which feature or fix.

But what exactly is a branch? Consider your main branch as a highway, with each commit being a car that enters the highway. You may decide you want to go take a look at something, like creating a new feature, so you need to get off of the highway for a bit to go see.

A branch is essentially a deviation from your main history, where you can freely play around with changes for a new feature or a bug fix. If you are happy with your changes, you can get back on the highway by merging the branch into main. If you aren't happy with your changes, you can delete the branch and switch back to main without accepting the changes.

Before creating a new branch, you view your branches with the git branch command. The output might look like this:

* main
Right now we only have the one branch, our default main branch. The asterisk (*) means that is the branch that you currently have "checked out". You'll learn more about that in a bit.

You can create a new branch with the git branch command, with an argument to specify the new branch's name:

git branch feature
This creates a new branch named feature. Let's take a look at our branches again with git branch:

  feature
* main
We can now see our new branch, but we are still on the main branch. We need to switch to our new branch by "checking it out". When you check out a new branch, you're telling Git to load the files in the exact state they were in at that point.

Let's check out our new branch with:

git checkout feature
or

git switch feature
And run git branch again to see:

* feature
  main
Notice that the asterisk has now moved to the branch you currently have "checked out".

Often times when you create a new branch, you will want to check it out immediately. Instead of creating the branch and then checking it out using two commands, you can create and switch to a branch in one command with:

git checkout -b feature
or

git switch -c feature
So now we've created and checked out a new branch. This branch is a clone of the main branch, it has all the same code that main did at the time you created the branch. Now, we can add any code to this branch without affecting the main branch. We've essentially gotten off the highway to create a feature. If you check your git status, you would see something like this:

On branch feature
nothing to commit, working tree clean
Create a new feature.md file by running this:

echo "This is our new feature" > feature.md
And now the status will look like this:

On branch feature
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	feature.md

nothing added to commit but untracked files present (use "git add" to track)
Next, it's time to commit your new feature. First, add the file to staging:

git add feature.md
Then, commit the changes:

git commit -m "my new feature"
Finally, push your feature branch to your repository:

git push -u origin feature
The -u flag connects your local feature branch to the remote one, so future pushes can be done with just git push.

Next, we will learn how to make a pull request for our new feature!
